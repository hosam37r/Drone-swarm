# droneswarm/droneflight.py
# Simulation: 10 drones, spoof starts at 10 minutes into a 30-minute flight (1 Hz).
# Outputs:
#  - swarm_google_satellite_overlay.png
#  - tracks_equal_scale_ENU.png
#  - tracks_zoom_endpoint.png
#  - drift_error_vs_time.png
#  - accel_4panel.png
#  - gyro_4panel.png
#  - traj3d_truth.png
#  - traj3d_spoof.png
#  - traj3d_combined.png   <-- NEW combined 3D plot (truth + spoof)
#  - swarm_tracks.csv
#  - imu_series.csv
#
# pip install pillow numpy matplotlib

import math
import io
import urllib.parse
import urllib.request
from typing import Tuple
import numpy as np
from PIL import Image, ImageDraw
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import os
import csv

# =========================
# 1) CONFIG
# =========================
API_KEY = "AIzaSyBviNwbX4Ktsi6_6wVOIYc9K1mcLHIfWS8"  # <-- put your Google Maps Static API key here

# Timing
FLIGHT_MINUTES   = 30
FIX_RATE_HZ      = 1
N_STEPS          = int(FLIGHT_MINUTES * 60 * FIX_RATE_HZ) + 1  # include start
SPOOF_START_MIN  = 10
SPOOF_START_STEP = int(SPOOF_START_MIN * 60 * FIX_RATE_HZ)

# Coordinates (DMS)
LAUNCH_DMS       = ("34°13'31.1\"N", "77°46'22.9\"W")
TRUTH_TARGET_DMS = ("34°13'33.7\"N", "77°52'18.8\"W")
DRIFT_TARGET_DMS = ("34°13'28.7\"N", "77°52'18.2\"W")

# Swarm & styles
N_DRONES       = 10
DRONE_SPREAD_M = 80.0   # total N-S spread (meters)

LINESTYLE = "--"
LW_T      = 1.4   # truth line width
LW_S      = 1.6   # spoof line width
ALPHA_T   = 0.95  # truth alpha
ALPHA_S   = 0.65  # spoof alpha

# Google Static Maps
IMG_SIZE = (1280, 1024)  # final PNG size (W,H)
MAPTYPE  = "satellite"
STATIC_SCALE = 2         # 1 or 2
TILE_SIZE = 256
GOOGLE_STATIC_MAX = 640  # per side (size=) at scale 1 or 2

# Outputs
OUT_OVERLAY = "swarm_google_satellite_overlay.png"
OUT_ENU     = "tracks_equal_scale_ENU.png"
OUT_ZOOM    = "tracks_zoom_endpoint.png"
OUT_ERR     = "drift_error_vs_time.png"
OUT_ACC4    = "accel_4panel.png"
OUT_GYR4    = "gyro_4panel.png"
OUT_TRUTH3D = "traj3d_truth.png"
OUT_SPOOF3D = "traj3d_spoof.png"
OUT_COMB3D  = "traj3d_combined.png"   # NEW
OUT_TRACKS  = "swarm_tracks.csv"
OUT_IMUCSV  = "imu_series.csv"

# =========================
# 2) GEO HELPERS
# =========================
def dms_to_dd(dms_str: str) -> float:
    s = dms_str.strip().replace(" ", "")
    import re
    m = re.match(r'(\d+)[°](\d+)[\']([\d\.]+)["]([NSEW])', s, re.IGNORECASE)
    if not m:
        raise ValueError(f"Bad DMS: {dms_str}")
    deg = float(m.group(1)); mins = float(m.group(2)); secs = float(m.group(3))
    hemi = m.group(4).upper()
    dd = deg + mins/60.0 + secs/3600.0
    if hemi in ["S","W"]:
        dd = -dd
    return dd

def meters_per_deg(lat_deg: float) -> Tuple[float, float]:
    lat_m_per_deg = 111_132.0
    lon_m_per_deg = 111_320.0 * math.cos(math.radians(lat_deg))
    return lat_m_per_deg, lon_m_per_deg

# =========================
# 3) TRAJECTORY BUILD (spoof starts later)
# =========================
def build_tracks(launch, truth_target, spoof_target,
                 n_drones, n_steps, spread_m,
                 spoof_start_step=SPOOF_START_STEP):
    latA, lonA = launch
    latT, lonT = truth_target
    latS, lonS = spoof_target

    # Truth: straight line A -> T
    truth_lat_base = np.linspace(latA, latT, n_steps)
    truth_lon_base = np.linspace(lonA, lonT, n_steps)

    # Spoof: identical to truth until spoof_start, then drift to S by the end
    spoof_lat_base = truth_lat_base.copy()
    spoof_lon_base = truth_lon_base.copy()
    n_drift = n_steps - spoof_start_step
    if n_drift > 1:
        spoof_lat_drift = np.linspace(truth_lat_base[spoof_start_step], latS, n_drift)
        spoof_lon_drift = np.linspace(truth_lon_base[spoof_start_step], lonS, n_drift)
        spoof_lat_base[spoof_start_step:] = spoof_lat_drift
        spoof_lon_base[spoof_start_step:] = spoof_lon_drift

    lat_scale, _ = meters_per_deg(latA)
    offsets = np.linspace(-spread_m/2, spread_m/2, n_drones)

    truth_lats, truth_lons, spoof_lats, spoof_lons = [], [], [], []
    for off in offsets:
        truth_lats.append(truth_lat_base + off / lat_scale)
        truth_lons.append(truth_lon_base.copy())
        spoof_lats.append(spoof_lat_base + off / lat_scale)
        spoof_lons.append(spoof_lon_base.copy())
    return truth_lons, truth_lats, spoof_lons, spoof_lats

# =========================
# 4) WEB MERCATOR + STATIC MAP
# =========================
def lonlat_to_pixel(lon: float, lat: float, zoom: int, tile_size: int = TILE_SIZE):
    siny = max(min(math.sin(math.radians(lat)), 0.9999), -0.9999)
    x = tile_size * (0.5 + lon/360.0) * (2**zoom)
    y = tile_size * (0.5 - 0.5 * math.log((1 + siny) / (1 - siny)) / math.pi) * (2**zoom)
    return x, y

def fit_zoom_for_bounds(lon_min, lat_min, lon_max, lat_max, width_px, height_px, padding_px=60, max_zoom=20):
    for z in range(max_zoom, -1, -1):
        x_min, y_max = lonlat_to_pixel(lon_min, lat_min, z)
        x_max, y_min = lonlat_to_pixel(lon_max, lat_max, z)
        span_x = abs(x_max - x_min) + 2*padding_px
        span_y = abs(y_max - y_min) + 2*padding_px
        if span_x <= width_px and span_y <= height_px:
            center_lon = (lon_min + lon_max)/2
            center_lat = (lat_min + lat_max)/2
            return z, center_lon, center_lat
    return 0, (lon_min + lon_max)/2, (lat_min + lat_max)/2

def fetch_google_static(center_lon, center_lat, zoom, size, maptype, api_key, scale=STATIC_SCALE):
    req_w = min(GOOGLE_STATIC_MAX, max(1, size[0] // scale))
    req_h = min(GOOGLE_STATIC_MAX, max(1, size[1] // scale))
    params = {
        "center": f"{center_lat},{center_lon}",
        "zoom": str(zoom),
        "size": f"{req_w}x{req_h}",
        "scale": str(scale),
        "maptype": maptype,
        "key": api_key
    }
    url = "https://maps.googleapis.com/maps/api/staticmap?" + urllib.parse.urlencode(params)
    with urllib.request.urlopen(url) as resp:
        data = resp.read()
    img = Image.open(io.BytesIO(data)).convert("RGBA")
    if img.size != size:
        img = img.resize(size, Image.LANCZOS)
    return img

# =========================
# 5) DRAWING HELPERS (PIL overlay)
# =========================
def rgba_from_tab10(i, alpha=230):
    r,g,b,_ = cm.get_cmap("tab10")(i % 10)
    return (int(r*255), int(g*255), int(b*255), int(alpha))

def draw_dashed_polyline(draw: ImageDraw.Draw, pts, dash_len=8, gap_len=6, width=3, color=(255,255,255,255)):
    if len(pts) < 2: return
    from math import hypot
    for (x1,y1),(x2,y2) in zip(pts[:-1], pts[1:]):
        dx, dy = x2-x1, y2-y1
        seg_len = hypot(dx, dy)
        if seg_len == 0: continue
        ux, uy = dx/seg_len, dy/seg_len
        dist, draw_dash = 0.0, True
        while dist < seg_len:
            d = min(dash_len if draw_dash else gap_len, seg_len - dist)
            if draw_dash:
                xa, ya = x1 + ux*dist, y1 + uy*dist
                xb, yb = x1 + ux*(dist+d), y1 + uy*(dist+d)
                draw.line([(xa,ya),(xb,yb)], fill=color, width=width)
            dist += d
            draw_dash = not draw_dash

def project_pts(lons, lats, center_lon, center_lat, zoom, W, H):
    cx, cy = lonlat_to_pixel(center_lon, center_lat, zoom)
    pts = []
    for lo, la in zip(lons, lats):
        px, py = lonlat_to_pixel(lo, la, zoom)
        x = px - cx + W/2
        y = py - cy + H/2
        pts.append((x, y))
    return pts

def draw_label(img, lon, lat, text, center_lon, center_lat, zoom, fill=(255,255,255,230)):
    W, H = img.size
    cx, cy = lonlat_to_pixel(center_lon, center_lat, zoom)
    px, py = lonlat_to_pixel(lon, lat, zoom)
    x = px - cx + W/2
    y = py - cy + H/2
    d = ImageDraw.Draw(img, "RGBA")
    r = 4
    d.ellipse((x-r, y-r, x+r, y+r), fill=fill)
    d.text((x+6, y-10), text, fill=fill)

def draw_tracks_on_image_with_spoofstart(img, center_lon, center_lat, zoom,
                                         truth_lons, truth_lats,
                                         spoof_lons, spoof_lats,
                                         spoof_start_step=SPOOF_START_STEP):
    """Truth full path; spoof segment only after spoof start."""
    W, H = img.size
    draw = ImageDraw.Draw(img, "RGBA")
    for idx, (tlo, tla, slo, sla) in enumerate(zip(truth_lons, truth_lats, spoof_lons, spoof_lats)):
        col_truth = rgba_from_tab10(idx, alpha=int(ALPHA_T*255))
        col_spoof = rgba_from_tab10(idx, alpha=int(ALPHA_S*255))

        pts_truth = project_pts(tlo, tla, center_lon, center_lat, zoom, W, H)
        draw_dashed_polyline(draw, pts_truth, dash_len=8, gap_len=6, width=int(LW_T*2), color=col_truth)

        if spoof_start_step < len(slo):
            pts_spoof = project_pts(slo[spoof_start_step:], sla[spoof_start_step:], center_lon, center_lat, zoom, W, H)
            draw_dashed_polyline(draw, pts_spoof, dash_len=8, gap_len=6, width=int(LW_S*2), color=col_spoof)

# =========================
# 6) MATPLOTLIB PLOTS (ENU + Zoom + Error vs Time)
# =========================
def enu_preview_and_zoom(launch_lon, launch_lat,
                         truth_lons, truth_lats,
                         spoof_lons, spoof_lats,
                         spoof_start_step=SPOOF_START_STEP,
                         out_enu=OUT_ENU, out_zoom=OUT_ZOOM):
    lat_scale, lon_scale = meters_per_deg(launch_lat)
    def to_EN(lon, lat):
        E = (lon - launch_lon) * lon_scale
        N = (lat - launch_lat) * lat_scale
        return E, N

    colors = cm.get_cmap("tab10", len(truth_lons))

    # Equal-scale ENU
    plt.figure(figsize=(9, 7))
    for d in range(len(truth_lons)):
        E_t, N_t = to_EN(truth_lons[d], truth_lats[d])
        E_s, N_s = to_EN(spoof_lons[d], spoof_lats[d])
        col = colors(d)
        plt.plot(E_t, N_t, ls=LINESTYLE, lw=LW_T, color=col, alpha=ALPHA_T, label="Truth" if d==0 else None)
        if spoof_start_step < len(E_s):
            plt.plot(E_s[spoof_start_step:], N_s[spoof_start_step:],
                     ls=LINESTYLE, lw=LW_S, color=col, alpha=ALPHA_S, label=f"Spoof (>{SPOOF_START_MIN}m)" if d==0 else None)
    plt.scatter([0], [0], marker="x", s=80, color="k")
    plt.text(0, 0, "  Launch A")
    plt.gca().set_aspect("equal", adjustable="datalim")
    plt.xlabel("East (m)"); plt.ylabel("North (m)")
    plt.title("Equal-scale ENU — spoof starts at 10 minutes")
    plt.grid(True, ls="--", alpha=0.3)
    plt.legend(fontsize=8, ncol=2)
    plt.tight_layout()
    plt.savefig(out_enu, dpi=150)
    plt.close()

    # Zoomed endpoint (last ~2 km along E for drone 0)
    E0, N0 = to_EN(truth_lons[0], truth_lats[0])
    mask = (E0 >= E0.max() - 2000)
    plt.figure(figsize=(8, 6))
    for d in range(len(truth_lons)):
        E_t, N_t = to_EN(truth_lons[d], truth_lats[d])
        E_s, N_s = to_EN(spoof_lons[d], spoof_lats[d])
        col = colors(d)
        plt.plot(E_t[mask], N_t[mask], ls=LINESTYLE, lw=LW_T+0.2, color=col, alpha=ALPHA_T)
        if spoof_start_step < len(E_s):
            start_idx = max(np.where(mask)[0][0], spoof_start_step) if np.any(mask) else spoof_start_step
            plt.plot(E_s[start_idx:], N_s[start_idx:], ls=LINESTYLE, lw=LW_S+0.2, color=col, alpha=ALPHA_S)
            # arrow at endpoint
            plt.arrow(E_t[-1], N_t[-1], E_s[-1]-E_t[-1], N_s[-1]-N_t[-1],
                      length_includes_head=True, head_width=5, head_length=10, alpha=0.85, color=col)
    plt.gca().set_aspect("equal", adjustable="datalim")
    plt.xlabel("East (m)"); plt.ylabel("North (m)")
    plt.title("Zoom near endpoint — drift after spoof onset")
    plt.grid(True, ls="--", alpha=0.3)
    plt.tight_layout()
    plt.savefig(out_zoom, dpi=150)
    plt.close()

def plot_drift_error_vs_time(launch_lat, truth_lons, truth_lats, spoof_lons, spoof_lats,
                             fix_rate_hz=FIX_RATE_HZ, out_path=OUT_ERR):
    lat_m, lon_m = meters_per_deg(launch_lat)
    t_lon, t_lat = truth_lons[0], truth_lats[0]
    s_lon, s_lat = spoof_lons[0], spoof_lats[0]

    dE = (s_lon - t_lon) * lon_m
    dN = (s_lat - t_lat) * lat_m
    err = np.sqrt(dE**2 + dN**2)
    t_sec = np.arange(len(err)) / fix_rate_hz
    t_min = t_sec / 60.0

    plt.figure(figsize=(9, 4.5))
    plt.plot(t_min, err, lw=2)
    plt.axvline(SPOOF_START_MIN, color="r", ls="--", label="Spoof start")
    plt.xlabel("Flight time (minutes)")
    plt.ylabel("Drift error |Δ| (m)")
    plt.title("Accumulated GPS Drift Error vs Flight Time")
    plt.grid(True, ls="--", alpha=0.3)
    plt.legend()
    plt.tight_layout()
    plt.savefig(out_path, dpi=150)
    plt.close()

    if len(err) > SPOOF_START_STEP + 1:
        per_broadcast_E = dE[SPOOF_START_STEP+1] - dE[SPOOF_START_STEP]
        per_broadcast_N = dN[SPOOF_START_STEP+1] - dN[SPOOF_START_STEP]
        per_broadcast_mag = math.hypot(per_broadcast_E, per_broadcast_N)
        print(f"Per-broadcast drift AFTER spoof starts: "
              f"North {per_broadcast_N:+.3f} m, East {per_broadcast_E:+.3f} m (|Δ|={per_broadcast_mag:.3f} m)")
    print(f"Final error after {t_min[-1]:.1f} min: {err[-1]:.1f} m")

# =========================
# 7) IMU SYNTHESIS (accel + gyro)
# =========================
def kinematics_from_EN(E, N, dt):
    vE = np.gradient(E, dt, edge_order=2)
    vN = np.gradient(N, dt, edge_order=2)
    aE = np.gradient(vE, dt, edge_order=2)
    aN = np.gradient(vN, dt, edge_order=2)
    return vE, vN, aE, aN

def yaw_and_rate_from_vel(vE, vN, dt):
    psi = np.arctan2(vN, vE)
    psi_unw = np.unwrap(psi)
    r = np.gradient(psi_unw, dt, edge_order=2)  # rad/s
    return psi_unw, r

def synthesize_imu_from_tracks(lons, lats, launch_lon, launch_lat,
                               fix_rate_hz=1.0,
                               acc_noise_std=0.08,       # m/s^2
                               gyro_noise_std_dps=0.08): # deg/s
    dt = 1.0 / fix_rate_hz
    lat_m, lon_m = meters_per_deg(launch_lat)
    E = (lons - launch_lon) * lon_m
    N = (lats - launch_lat) * lat_m

    vE, vN, aE, aN = kinematics_from_EN(E, N, dt)
    _, yaw_rate = yaw_and_rate_from_vel(vE, vN, dt)  # rad/s → deg/s
    gyroZ_dps = np.degrees(yaw_rate)

    accE = aE + np.random.normal(0.0, acc_noise_std, size=len(aE))
    accN = aN + np.random.normal(0.0, acc_noise_std, size=len(aN))
    gyroX = np.random.normal(0.0, gyro_noise_std_dps, size=len(aE))
    gyroY = np.random.normal(0.0, gyro_noise_std_dps, size=len(aE))
    gyroZ = gyroZ_dps + np.random.normal(0.0, gyro_noise_std_dps, size=len(aE))

    t_sec = np.arange(len(E)) * dt
    return {"t_sec": t_sec, "accE": accE, "accN": accN, "gyroX": gyroX, "gyroY": gyroY, "gyroZ": gyroZ}

# ----- IMU 4-panel figures -----
def plot_accel_4panel(truth_imu, spoof_imu, spoof_start_min, out_path=OUT_ACC4):
    tT = truth_imu["t_sec"] / 60.0
    tS = spoof_imu["t_sec"] / 60.0
    fig, axes = plt.subplots(2, 2, figsize=(12, 7), sharex=True)
    ax11, ax12, ax21, ax22 = axes.ravel()

    ax11.plot(tT, truth_imu["accE"], lw=1.2); ax11.axvline(spoof_start_min, color="r", ls="--", lw=1)
    ax11.set_title("Truth: accX (East)"); ax11.set_ylabel("m/s²"); ax11.grid(True, ls="--", alpha=0.3)
    ax12.plot(tT, truth_imu["accN"], lw=1.2); ax12.axvline(spoof_start_min, color="r", ls="--", lw=1)
    ax12.set_title("Truth: accY (North)"); ax12.grid(True, ls="--", alpha=0.3)
    ax21.plot(tS, spoof_imu["accE"], lw=1.2); ax21.axvline(spoof_start_min, color="r", ls="--", lw=1, label="Spoof start")
    ax21.set_title("Spoofed: accX (East)"); ax21.set_ylabel("m/s²"); ax21.grid(True, ls="--", alpha=0.3); ax21.legend(fontsize=8)
    ax22.plot(tS, spoof_imu["accN"], lw=1.2); ax22.axvline(spoof_start_min, color="r", ls="--", lw=1)
    ax22.set_title("Spoofed: accY (North)"); ax22.grid(True, ls="--", alpha=0.3)
    for ax in (ax21, ax22): ax.set_xlabel("Time (min)")
    fig.suptitle("Accelerometer Time Series — Truth vs Spoofed (2×2)", y=1.02)
    fig.tight_layout(); fig.savefig(out_path, dpi=150, bbox_inches="tight"); plt.close(fig)

def plot_gyro_4panel(truth_imu, spoof_imu, spoof_start_min, out_path=OUT_GYR4):
    tT = truth_imu["t_sec"] / 60.0
    tS = spoof_imu["t_sec"] / 60.0
    fig, axes = plt.subplots(2, 2, figsize=(12, 7), sharex=True)
    ax11, ax12, ax21, ax22 = axes.ravel()

    ax11.plot(tT, truth_imu["gyroX"], lw=1.2); ax11.axvline(spoof_start_min, color="r", ls="--", lw=1)
    ax11.set_title("Truth: gyroX (deg/s)"); ax11.set_ylabel("deg/s"); ax11.grid(True, ls="--", alpha=0.3)
    ax12.plot(tT, truth_imu["gyroY"], lw=1.2); ax12.axvline(spoof_start_min, color="r", ls="--", lw=1)
    ax12.set_title("Truth: gyroY (deg/s)"); ax12.grid(True, ls="--", alpha=0.3)
    ax21.plot(tS, spoof_imu["gyroX"], lw=1.2); ax21.axvline(spoof_start_min, color="r", ls="--", lw=1, label="Spoof start")
    ax21.set_title("Spoofed: gyroX (deg/s)"); ax21.set_ylabel("deg/s"); ax21.grid(True, ls="--", alpha=0.3); ax21.legend(fontsize=8)
    ax22.plot(tS, spoof_imu["gyroY"], lw=1.2); ax22.axvline(spoof_start_min, color="r", ls="--", lw=1)
    ax22.set_title("Spoofed: gyroY (deg/s)"); ax22.grid(True, ls="--", alpha=0.3)
    for ax in (ax21, ax22): ax.set_xlabel("Time (min)")
    fig.suptitle("Gyroscope Time Series — Truth vs Spoofed (2×2)", y=1.02)
    fig.tight_layout(); fig.savefig(out_path, dpi=150, bbox_inches="tight"); plt.close(fig)

# =========================
# 8) 3D TRAJECTORY PLOTS
# =========================
def plot_traj_3d(truth_lons, truth_lats, spoof_lons, spoof_lats,
                 launch_lon, launch_lat, fix_rate_hz=1.0,
                 out_truth=OUT_TRUTH3D, out_spoof=OUT_SPOOF3D,
                 spoof_start_min=SPOOF_START_MIN):
    """Two separate 3D figures: Truth and Spoofed (Drone 0)."""
    from mpl_toolkits.mplot3d import Axes3D  # noqa: F401
    lat_m, lon_m = meters_per_deg(launch_lat)
    dt = 1.0 / fix_rate_hz
    t_sec = np.arange(len(truth_lons[0])) * dt
    t_min = t_sec / 60.0

    # Drone 0 tracks
    tlo = np.array(truth_lons[0]); tla = np.array(truth_lats[0])
    slo = np.array(spoof_lons[0]); sla = np.array(spoof_lats[0])

    E_t = (tlo - launch_lon) * lon_m; N_t = (tla - launch_lat) * lat_m
    E_s = (slo - launch_lon) * lon_m; N_s = (sla - launch_lat) * lat_m

    # Truth 3D
    fig = plt.figure(figsize=(8.8, 7.2))
    ax = fig.add_subplot(111, projection='3d')
    ax.plot(E_t, N_t, t_min, lw=2)
    ax.set_xlabel("East (m)"); ax.set_ylabel("North (m)"); ax.set_zlabel("Time (min)")
    ax.set_title("3D Trajectory — Truth (Drone 0)")
    rngE = E_t.max()-E_t.min(); rngN = N_t.max()-N_t.min()
    ax.set_box_aspect((rngE if rngE>0 else 1, rngN if rngN>0 else 1, t_min.max() if t_min.max()>0 else 1))
    plt.tight_layout(); plt.savefig(out_truth, dpi=150, bbox_inches="tight"); plt.close(fig)

    # Spoof 3D
    fig = plt.figure(figsize=(8.8, 7.2))
    ax = fig.add_subplot(111, projection='3d')
    ax.plot(E_s, N_s, t_min, lw=2)
    idx = int(spoof_start_min * 60 * fix_rate_hz)
    if 0 <= idx < len(t_min):
        ax.scatter([E_s[idx]], [N_s[idx]], [t_min[idx]], s=60, depthshade=True)
        ax.text(E_s[idx], N_s[idx], t_min[idx], "  spoof start")
    ax.set_xlabel("East (m)"); ax.set_ylabel("North (m)"); ax.set_zlabel("Time (min)")
    ax.set_title("3D Trajectory — Spoofed (Drone 0)")
    rngE = E_s.max()-E_s.min(); rngN = N_s.max()-N_s.min()
    ax.set_box_aspect((rngE if rngE>0 else 1, rngN if rngN>0 else 1, t_min.max() if t_min.max()>0 else 1))
    plt.tight_layout(); plt.savefig(out_spoof, dpi=150, bbox_inches="tight"); plt.close(fig)

def plot_traj_3d_combined(truth_lons, truth_lats, spoof_lons, spoof_lats,
                          launch_lon, launch_lat, fix_rate_hz=1.0,
                          out_path=OUT_COMB3D, spoof_start_min=SPOOF_START_MIN):
    """
    NEW: Single 3D figure with BOTH trajectories (Drone 0):
      - Truth path in one color
      - Spoofed path in another color
      - Marker at spoof start
    """
    from mpl_toolkits.mplot3d import Axes3D  # noqa: F401
    lat_m, lon_m = meters_per_deg(launch_lat)
    dt = 1.0 / fix_rate_hz
    t_sec = np.arange(len(truth_lons[0])) * dt
    t_min = t_sec / 60.0

    # Drone 0 tracks
    tlo = np.array(truth_lons[0]); tla = np.array(truth_lats[0])
    slo = np.array(spoof_lons[0]); sla = np.array(spoof_lats[0])

    E_t = (tlo - launch_lon) * lon_m; N_t = (tla - launch_lat) * lat_m
    E_s = (slo - launch_lon) * lon_m; N_s = (sla - launch_lat) * lat_m

    # Colors
    col_truth = "#1f77b4"  # tab:blue
    col_spoof = "#d62728"  # tab:red

    fig = plt.figure(figsize=(9.6, 7.6))
    ax = fig.add_subplot(111, projection='3d')
    ax.plot(E_t, N_t, t_min, lw=2, label="Truth (Drone 0)", color=col_truth)
    ax.plot(E_s, N_s, t_min, lw=2, label="Spoofed (Drone 0)", color=col_spoof)

    # Spoof start marker
    idx = int(spoof_start_min * 60 * fix_rate_hz)
    if 0 <= idx < len(t_min):
        ax.scatter([E_s[idx]], [N_s[idx]], [t_min[idx]], s=70, color=col_spoof, depthshade=True)
        ax.text(E_s[idx], N_s[idx], t_min[idx], "  spoof start", color=col_spoof)

    ax.set_xlabel("East (m)"); ax.set_ylabel("North (m)"); ax.set_zlabel("Time (min)")
    ax.set_title("3D Trajectory (Combined) — Truth vs Spoofed")
    ax.legend(loc="upper left")

    # Aspect roughly equal in XY
    rngE = np.ptp(np.concatenate([E_t, E_s])); rngN = np.ptp(np.concatenate([N_t, N_s]))
    ax.set_box_aspect((rngE if rngE>0 else 1, rngN if rngN>0 else 1, t_min.max() if t_min.max()>0 else 1))

    plt.tight_layout(); plt.savefig(out_path, dpi=150, bbox_inches="tight"); plt.close(fig)

# =========================
# 9) MAIN
# =========================
def main():
    # Ensure outputs land next to the script
    os.chdir(os.path.dirname(os.path.abspath(__file__)))

    # Convert DMS
    latA = dms_to_dd(LAUNCH_DMS[0]); lonA = dms_to_dd(LAUNCH_DMS[1])
    latT = dms_to_dd(TRUTH_TARGET_DMS[0]); lonT = dms_to_dd(TRUTH_TARGET_DMS[1])
    latS = dms_to_dd(DRIFT_TARGET_DMS[0]); lonS = dms_to_dd(DRIFT_TARGET_DMS[1])

    # Build tracks
    truth_lons, truth_lats, spoof_lons, spoof_lats = build_tracks(
        (latA, lonA), (latT, lonT), (latS, lonS),
        n_drones=N_DRONES, n_steps=N_STEPS, spread_m=DRONE_SPREAD_M,
        spoof_start_step=SPOOF_START_STEP
    )

    # Fit map bounds & fetch background
    all_lons = np.concatenate([*truth_lons, *spoof_lons])
    all_lats = np.concatenate([*truth_lats, *spoof_lats])
    lon_min, lon_max = float(all_lons.min()), float(all_lons.max())
    lat_min, lat_max = float(all_lats.min()), float(all_lats.max())
    zoom, center_lon, center_lat = fit_zoom_for_bounds(
        lon_min, lat_min, lon_max, lat_max, IMG_SIZE[0], IMG_SIZE[1], padding_px=60, max_zoom=20
    )

    # Try to draw overlay (skip gracefully if API errors)
    try:
        img = fetch_google_static(center_lon, center_lat, zoom, IMG_SIZE, MAPTYPE, API_KEY, scale=STATIC_SCALE)
        draw_tracks_on_image_with_spoofstart(img, center_lon, center_lat, zoom,
                                             truth_lons, truth_lats,
                                             spoof_lons, spoof_lats,
                                             spoof_start_step=SPOOF_START_STEP)
        draw_label(img, lonA, latA, "A (Launch)", center_lon, center_lat, zoom)
        draw_label(img, lonT, latT, "B_truth",   center_lon, center_lat, zoom)
        draw_label(img, lonS, latS, "B_spoof",   center_lon, center_lat, zoom)
        lo0_s, la0_s = spoof_lons[0][SPOOF_START_STEP], spoof_lats[0][SPOOF_START_STEP]
        draw_label(img, lo0_s, la0_s, f"Start spoof @ {SPOOF_START_MIN} min", center_lon, center_lat, zoom, fill=(255,200,0,230))
        img.save(OUT_OVERLAY)
        print(f"Saved: {OUT_OVERLAY}  (Center: {center_lat:.6f}, {center_lon:.6f}  Zoom: {zoom})")
    except urllib.error.HTTPError:
        print("Google Static Maps fetch failed. Check API key/billing/restrictions.")
        print("Continuing without overlay image...")

    # ENU & Zoom plots
    enu_preview_and_zoom(lonA, latA, truth_lons, truth_lats, spoof_lons, spoof_lats,
                         spoof_start_step=SPOOF_START_STEP,
                         out_enu=OUT_ENU, out_zoom=OUT_ZOOM)
    print(f"Saved: {OUT_ENU}")
    print(f"Saved: {OUT_ZOOM}")

    # Error vs time
    plot_drift_error_vs_time(latA, truth_lons, truth_lats, spoof_lons, spoof_lats,
                             fix_rate_hz=FIX_RATE_HZ, out_path=OUT_ERR)
    print(f"Saved: {OUT_ERR}")

    # IMU synthesis for one representative drone (index 0)
    truth_track_lon = np.array(truth_lons[0])
    truth_track_lat = np.array(truth_lats[0])
    spoof_track_lon = np.array(spoof_lons[0])
    spoof_track_lat = np.array(spoof_lats[0])

    truth_imu = synthesize_imu_from_tracks(truth_track_lon, truth_track_lat,
                                           launch_lon=lonA, launch_lat=latA,
                                           fix_rate_hz=FIX_RATE_HZ)
    spoof_imu = synthesize_imu_from_tracks(spoof_track_lon, spoof_track_lat,
                                           launch_lon=lonA, launch_lat=latA,
                                           fix_rate_hz=FIX_RATE_HZ)

    # IMU 4-panel figures
    plot_accel_4panel(truth_imu, spoof_imu, SPOOF_START_MIN, out_path=OUT_ACC4)
    print(f"Saved: {OUT_ACC4}")
    plot_gyro_4panel(truth_imu, spoof_imu, SPOOF_START_MIN, out_path=OUT_GYR4)
    print(f"Saved: {OUT_GYR4}")

    # 3D trajectory figures (separate)
    plot_traj_3d(truth_lons, truth_lats, spoof_lons, spoof_lats,
                 launch_lon=lonA, launch_lat=latA, fix_rate_hz=FIX_RATE_HZ,
                 out_truth=OUT_TRUTH3D, out_spoof=OUT_SPOOF3D,
                 spoof_start_min=SPOOF_START_MIN)
    print(f"Saved: {OUT_TRUTH3D}")
    print(f"Saved: {OUT_SPOOF3D}")

    # NEW: 3D combined figure
    plot_traj_3d_combined(truth_lons, truth_lats, spoof_lons, spoof_lats,
                          launch_lon=lonA, launch_lat=latA, fix_rate_hz=FIX_RATE_HZ,
                          out_path=OUT_COMB3D, spoof_start_min=SPOOF_START_MIN)
    print(f"Saved: {OUT_COMB3D}")

    # IMU CSV (truth & spoof)
    with open(OUT_IMUCSV, "w", newline="") as f:
        w = csv.writer(f)
        w.writerow(["flight","t_sec","accE","accN","gyroX","gyroY","gyroZ"])
        for i in range(len(truth_imu["t_sec"])):
            w.writerow(["truth", truth_imu["t_sec"][i], truth_imu["accE"][i], truth_imu["accN"][i],
                        truth_imu["gyroX"][i], truth_imu["gyroY"][i], truth_imu["gyroZ"][i]])
        for i in range(len(spoof_imu["t_sec"])):
            w.writerow(["spoof", spoof_imu["t_sec"][i], spoof_imu["accE"][i], spoof_imu["accN"][i],
                        spoof_imu["gyroX"][i], spoof_imu["gyroY"][i], spoof_imu["gyroZ"][i]])
    print(f"Saved: {OUT_IMUCSV}")

    # Tracks CSV (all drones, all steps)
    rows = []
    for d in range(N_DRONES):
        for i in range(N_STEPS):
            rows.append({
                "t_sec": i / FIX_RATE_HZ,
                "drone_id": d,
                "truth_lat": float(truth_lats[d][i]),
                "truth_lon": float(truth_lons[d][i]),
                "spoof_lat": float(spoof_lats[d][i]),
                "spoof_lon": float(spoof_lons[d][i]),
                "is_spoof_phase": int(i >= SPOOF_START_STEP)
            })
    with open(OUT_TRACKS, "w", newline="") as f:
        w = csv.DictWriter(f, fieldnames=rows[0].keys())
        w.writeheader(); w.writerows(rows)
    print(f"Saved: {OUT_TRACKS}")

if __name__ == "__main__":
    main()
